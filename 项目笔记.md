# 文件解释

```
assets：用于存放静态资源文件，如图片、字体、样式表等。这些文件在项目中可以通过相对路径进行引用。例	 		   如，可以将项目所需的图片放在assets文件夹中，并在Vue组件中使用<img>标签引用这些图片
apis：用于存放与后端接口通信相关的代码，例如封装的 API 请求函数。
composables：用于存放通用逻辑函数(💡倒计时操作)，可复用的逻辑代码片段，例如自定义的组合式函数。
components：目录下放置全局通用的组件，实现多个业务模块中共享
directives：用于存放自定义指令的代码，例如自定义的全局指令。
router：用于存放路由相关的代码，例如路由配置文件和路由守卫。
stores：用于存放状态管理相关的代码，例如 Vuex 的模块、状态和操作等。
styles：用于存放样式相关的代码，例如全局样式文件或组件样式文件。
utils：用于存放通用的工具函数或工具类。
views：用于存放页面级组件，即与路由一一对应的组件。
```

git仓库提交操作

[(41条消息) Git: ‘LF will be replaced by CRLF the next time Git touches it‘ 问题解决与思考_Babylonxun的博客-CSDN博客](https://blog.csdn.net/Babylonxun/article/details/126598477)

```
1.git config --global core.autocrlf true
2.git commit -m "保存部分名称"
```



# 1.生成项目 cmd 命令下执行npm init vue@lastest，生成vue3项目文件夹



# 2.在vs中安装vue3项目文件中package.json中所依赖的包，执行npm install



# 3.运行项目检测是否能跑起来 npm run dev  /  npm run server

```
`npm run dev`和`npm run server`是两个常见的命令，用于在运行项目时启动开发服务器。

	1. `npm run dev`：这是一个常见的命令，用于启动开发模式下的项目。通常，该命令会执行一系列脚本，例如编译代码、启动开发服务器、监听文件变化等。它通常用于在开发过程中实时编译和预览项目的变化。
	2. `npm run server`：这是一个自定义的命令，具体的功能取决于项目的配置。有些项目可能将其用于启动本地服务器，提供API服务或模拟后端环境。这个命令通常用于在开发过程中模拟后端服务或提供其他开发所需的服务。

具体使用哪个命令取决于项目的配置和需求。通常，在项目的`package.json`文件中可以找到这些命令的定义和配置。你可以查看项目的文档或者配置文件，以确定应该使用哪个命令来运行项目。
```

如果是dev 执行npm run dev

如果是server执行npm run server

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230702123709960.png" alt="image-20230702123709960" style="zoom:50%;" />



# 4.将项目上传至git仓库

```
当你使用git进行版本控制时，你的代码会被存储在一个或多个git仓库中。这些仓库可以是本地仓库或远程仓库。

   1.本地仓库：本地仓库是存储在你的计算机上的git仓库。当你在项目目录中执行git init命令时，会在该目录下创建一个本地仓库。本地仓库包含了你项目的所有代码、历史记录和分支等信息。
   2.远程仓库：远程仓库是存储在远程服务器上的git仓库。你可以将本地仓库中的代码推送到远程仓库中，以便与团队成员共享和备份代码。常见的远程仓库服务有GitHub、GitLab和Bitbucket等。

当你执行git push命令将代码推送到远程仓库时，你的代码会被上传到远程仓库中。其他团队成员可以从远程仓库中拉取代码，并在自己的本地仓库中进行修改和提交。

在团队协作中，通常会有一个中央仓库作为主要的远程仓库，团队成员将代码推送到该仓库并从该仓库拉取代码。这样可以保持代码的一致性和统一性。

总之，你的代码最终会被存储在本地仓库和远程仓库中。本地仓库用于保存你的开发历史和分支信息，而远程仓库用于共享和备份代码。
```

<img src="C:\Users\11569\Pictures\Screenshots\屏幕截图 2023-07-02 123332.png" alt="屏幕截图 2023-07-02 123332" style="zoom:50%;" />



# 5.jsconfig.json配置别名路径

[**输入@/即可跳出src下所有文件**]()

> 配置别名路径可以在写代码时联想提示路径,并没有做实际的路径转化

```json
{
  "compilerOptions" : {
    "baseUrl" : "./",
    "paths" : {
      "@/*":["src/*"]
    }
  }
}
```

实际上是在vite.config做了转化，将@转化为路径，这样使得导入的组件路径生效。做到真正导入组件

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230702133624433.png" alt="image-20230702133624433" style="zoom:67%;" />



# 6.elementPlus引入修改主题色

```
P23、24
```

## 1. 安装elementPlus和自动导入插件

```bash
npm i elementPlus
npm install -D unplugin-vue-components unplugin-auto-import
```

## 2. 配置自动按需导入

```javascript
// 引入插件
import AutoImport from 'unplugin-auto-import/vite'
import Components from 'unplugin-vue-components/vite'
import { ElementPlusResolver } from 'unplugin-vue-components/resolvers'


export default defineConfig({
  plugins: [
    // 配置插件
    AutoImport({
      resolvers: [ElementPlusResolver()],
    }),
    Components({
      resolvers: [ElementPlusResolver()],
    }),
  ]
})
```

## 3.elementPlus修改主题色

安装sass

配置文件styles/element/index.sass，将已经准备好的主题色方案放入index.sass中（用于覆盖默认主题色）

在vite.config.js配置文件中：

​		1.通知我们将采用sass语言替换默认主题色（修改componets中的resolvers）

​		2.将准备好的index.sass文件添加到css配置项中



# 7.axios基础配置

## 1. 安装axios

```bash
npm i axios
```

## 2. 基础配置

> 官方文档地址：[https://axios-http.com/zh/docs/intro](https://axios-http.com/zh/docs/intro)
> 基础配置通常包括：
>
> 1. 实例化 - baseURL + timeout
> 2. 拦截器 - 携带token 401拦截等

```javascript
//utils文件下配置请求操作
import axios from 'axios'

// 创建axios实例
const httpInstance = axios.create({
    baseURL: 'http://pcapi-xiaotuxian-front-devtest.itheima.net',
    timeout: 5000
})

// axios请求拦截器
httpInstance.interceptors.request.use(config => {
    return config
  }, e => Promise.reject(e))
  
  // axios响应式拦截器
httpInstance.interceptors.response.use(res => res.data, e => {
    return Promise.reject(e)
  })

export default httpInstance
```

## 3. 封装API并测试请求

```javascript
//src文件中apis下创建API们的文件
import httpInstance from "@/utils/http";

export function getCategory() {
    return httpInstance({
        url: 'home/category/head'
    })
}
```

## 4.测试

main.js

![image-20230703125100637](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703125100637.png)



# 8.路由设计

```
默认的二级路由配置时path:''，置空即可自动显示二级路由，当你访问一级路由时，一级路由中自动显示path置空的那个二级路由
```

Layout和Login同为一级路由，当页面打开时，由于Layout的path是’ / ‘，所以页面打开默认显示Layout组件内容，此时配置Layout组件中二级路由内容，二级路由为Home和Category，由于二级路由的path无需加/，所以同一可以利用这个技巧，将Home的path : ' '  这样就是默认显示Home这个二级路由的组件内容

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703144309209.png" alt="image-20230703144309209" style="zoom:67%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703144553300.png" alt="image-20230703144553300" style="zoom:67%;" />



路由设计原则：找页面的切换方式，如果是整体切换，则为一级路由，如果是在一级路由的内部进行的内容切换，则为二级路由

```html
<template>
  我是登录页
</template>
```

```html
<template>
  我是首页
</template>
```

```html
<template>
  我是home
</template>
```

```html
<template>
  我是分类
</template>
```

```javascript
// createRouter：创建router实例对象
// createWebHistory：创建history模式的路由

import { createRouter, createWebHistory } from 'vue-router'
import Login from '@/views/Login/index.vue'
import Layout from '@/views/Layout/index.vue'
import Home from '@/views/Home/index.vue'
import Category from '@/views/Category/index.vue'

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  // path和component对应关系的位置
  routes: [
    {
      path: '/',
      component: Layout,
      children: [
        {
          path: '',
          component: Home
        },
        {
          path: 'category',
          component: Category
        }
      ]
    },
    {
      path: '/login',
      component: Login
    }
  ]
})

export default router
```

# 9.scss变量自动导入

**[无需导入样式文件，直接使用定义好的颜色名称即可在项目中任意位置使用这些样式]()**

如：color：$xtxColor

```css
$xtxColor: #27ba9b;
$helpColor: #e26237;
$sucColor: #1dc779;
$warnColor: #ffb302;
$priceColor: #cf4444;
```

**[自动导入定制化样式文件进行样式覆盖]()**

```json
css: {
    preprocessorOptions: {
      scss: {
        // 自动导入scss文件，自动导入定制化样式文件进行样式覆盖
        additionalData: `
          @use "@/styles/element/index.scss" as *;
          @use "@/styles/var.scss" as *;
        `,
      }
    }
}
```





# 10.搭建Layout静态页面

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703155027456.png" alt="image-20230703155027456" style="zoom:70%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703155108028.png" alt="image-20230703155108028" style="zoom:67%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703155140037.png" alt="image-20230703155140037" style="zoom:50%;" />

### 引入阿里字体图标

在阿里字体图标官网中，我们使用font-class引入字体图标，导入链接，然后即可使用

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703155209508.png" alt="image-20230703155209508" style="zoom:50%;" />

**[使用方法：]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703155322072.png" alt="image-20230703155322072" style="zoom:50%;" />

随后在html代码中引入阿里字符图标链接，使用👇格式导入不同的阿里字体图标

 <i class="iconfont icon-search"></i>

<i class="iconfont icon-user">



# 11.吸顶导航交互实现

## 1. 准备组件静态结构

LayoutFixed组件

## 2. 渲染基础数据

## 3. 实现吸顶交互

> 核心逻辑：根据滚动距离判断当前show类名是否显示，大于78显示，小于78，不显示

```vue
<script setup>
import LayoutHeaderUl from './LayoutHeaderUl.vue'
// vueUse
import { useScroll } from '@vueuse/core'
const { y } = useScroll(window)
</script>

<template>
  <div class="app-header-sticky" :class="{ show: y > 78 }">
    <!-- 省略部分代码 -->
  </div>
</template>
```

**vueuse是vue推出的，封装了大量api，这里我们使用useScroll，const { y } = useScroll(window)将窗口纵向Y滚动距离解构赋值给变量y，通过y做判断是否显示导航条组件**

```
https://vueuse.org/core/useScroll/#usescroll
```

**[动态绑定样式，当y值，也就是页面滚动距离大于78时，为这个div添加两个class=“show”]()**

![image-20230703224142379](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703224142379.png)





# 12.滚动导航条和导航条优化

### Pinia优化重复请求

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703224824784.png" alt="image-20230703224824784" style="zoom:50%;" />



​		通过父组件index.vue发送请求，一次到位，这样就不会让滚到导航组件LayoutFixed和LayoutHeader两个组件都去发送请求获取导航栏数据了

​		父组件负责发请求，这样数据就存到了category.js中的categoryList中了，当有子组件想使用categoryList数据时，只需要导入`import { useCategoryStore } from '@/stores/category'`这个方法，然后执行`const categoryStore = useCategoryStore()`，就可以通过`categoryStore.categoryList`拿到导航栏数据了

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230703233657061.png" alt="image-20230703233657061" style="zoom:50%;" />



# 13.home模块渲染

​	通过请求得到的数据，也就是👆图中categoryStore.categoryList中的数据，最大层的.name是大类的name，位于home侧导航栏的大字，而children中的数据是测导航栏大字右边的小字内容，也可通过循环进行渲染，最后是鼠标经过每个侧导航栏时显示的内容，其数据位于goods数组中，依旧通过循环进行渲染

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704000857552.png" alt="image-20230704000857552" style="zoom:50%;" />

![image-20230704001409333](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704001409333.png)



# 14.banner轮播图实现

从服务器发送请求获取轮播图所需要的而数据，再通过element组件 库中的轮播图组件实现轮播图效果

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704142201216.png" alt="image-20230704142201216" style="zoom: 50%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704142233660.png" alt="image-20230704142233660" style="zoom: 50%;" />

```
如果你通过函数func发送了一个AJAX请求，并且该函数返回了该请求的响应，那么你可以将返回值赋给一个变量p，然后在一个异步函数中使用await p来获取响应体中的数据。

下面是一个示例代码：

async function getData() {
  const p = func(); // 发送AJAX请求并返回响应
  const response = await p; // 等待p的执行结果，即获取响应
  const data = response.data; // 假设响应的数据在response对象的data属性中
  console.log(data); // 使用响应数据进行处理
}

getData();
在上面的代码中，我们定义了一个异步函数getData，在函数体内部，我们通过调用func函数发送了一个AJAX请求，并将返回的响应赋给变量p。然后，我们使用await p等待p的执行结果，即获取到了响应。最后，我们可以通过访问响应对象response的属性来获取响应体中的数据，并进行相应的处理。

需要注意的是，使用await关键字必须在异步函数中，所以我们将整个操作封装在了getData函数中，并在函数体内部调用了getData函数来执行异步操作
```



# 15.新鲜好物实现

## 1. 纯静态结构

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704151153737.png" alt="image-20230704151153737" style="zoom:50%;" />

## 2.获取数据渲染页面

实际上有很多个类似新鲜好物的模块，像👇👇图这样的模块有很多个（一个模块是一个HomePanel实例），我们可以将不同的数据区分，将相同的部分提取（如结构样式），统一交由HomeNew组件管理，可以通过defineProps传递各个模块之间互异的数据，这个叫新鲜好物，下一个可能是优惠好物，最终都是通过接口从服务端获取数据并作渲染

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704154554099.png" alt="image-20230704154554099" style="zoom:52%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704154142940.png" alt="image-20230704154142940" style="zoom:50%;" />



![image-20230704154109263](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704154109263.png)







# 16.图片懒加载指令

## 1.自定义指令v-img-lazy

```rus
	在vue3中，自定义全局指令用到了app.directive函数（这里是全局指令，所以在项目入口的main.js中定义这个全局指令），第一个参数是自定义指令名称，第二个参数是一个对象，对象中用很多生命周期函数名做函数，这里mounted函数相当于自定义指令操作中的inserted函数（指令所在元素被插入页面时执行），mounted函数中的参数el和binding依旧是绑定的元素和绑定元素的信息，经常.vlaue取到值（绑定img元素时.value取到的是它的src值）
	
	在该指令中我们实现绑定元素出现在页面上时再进行加载图片操作，也就是为元素赋上有效的src值，显示该图片，这里我们使用了vueuse中的函数💡监视元素是否出现在可视窗口，isIntersecting是一个布尔值，元素出现在可视窗口则为true，，这是我们通过if判断，让绑定元素出现在窗口时为其附上binding.value
	💡<img v-img-lazy="item.picture" alt="">，binding.value，也就图片的src地址
```

```
mounted钩子函数是Vue指令的生命周期钩子之一，它在指令绑定的元素被插入到DOM中时调用。在懒加载插件中，mounted钩子函数用于初始化懒加载指令。

懒加载的详细流程如下：

	1 在Vue组件中使用<img v-img-lazy="cate.picture" />指令，将需要懒加载的图片路径绑定到cate.picture。并且这个img元素会被懒加载指令解析。在mounted钩子函数中，el是默认的参数，它表示指令绑定的元素，也就是这个img元素。el.src===img.src
	2 在懒加载插件的install方法中，注册了一个名为img-lazy的指令。
	3 当指令绑定的元素img被插入到DOM中时，mounted钩子函数会被调用。
	4 在mounted钩子函数中，通过useIntersectionObserver函数创建了一个IntersectionObserver实例，并传入需要观察的元素el和回调函数。
	5 回调函数接收一个Intersection Observer Entry数组作为参数（💡即[{ isIntersecting }]），其中包含了与观察元素相关的信息，如是否进入了视口。
	6 在回调函数中，通过解构赋值获取到isIntersecting属性，判断元素是否进入了视口。
	7 如果元素进入了视口，就将binding.value的值（即cate.picture的值）赋给el.src，实现图片的懒加载。
	8 调用stop函数停止监听元素的可见性变化，避免重复加载图片。

总结起来，懒加载插件的流程就是通过Intersection Observer API来监听元素的可见性变化，当元素进入视口时，将绑定的图片路径赋值给元素的src属性，实现图片的懒加载。
```

![image-20230821162730980](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230821162730980.png)

![image-20230704232006356](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704232006356.png)

## 2.vue3中如何定义插件

在Vue 3中，`install`函数是一个用于安装插件的函数。它是一个可选的静态方法，当我们创建自定义插件时，可以选择定义`install`函数以便在应用中注册和使用插件。

当我们调用`app.use()`方法注册插件时，Vue 会自动调用该插件的`install`函数，并将应用实例 `app` 作为参数传递给该函数。因此，我们可以在`install`函数内部执行一些插件的初始化工作，例如注册全局组件、添加全局指令、扩展应用实例等。

`install`函数的主要目的是封装和暴露插件中的功能，以便其他开发者可以方便地在应用中使用该插件。通常情况下，我们会在`install`函数内部使用 `app.component`、`app.directive` 等方法注册组件、指令等。

下面是一个简单的示例，展示了如何在Vue 3中创建一个插件并使用`install`函数：

```
// myPlugin.js

const MyPlugin = {
  install(app) {
    // 注册全局组件
    app.component('my-component', MyComponent);

    // 添加全局指令
    app.directive('my-directive', MyDirective);

    // 扩展应用实例
    app.config.globalProperties.$myMethod = () => {
      console.log('This is my method');
    };
  }
};

export default MyPlugin;
```

然后，在主应用程序中使用该插件时，可以使用`app.use()`方法来注册插件：

```
// main.js

import { createApp } from 'vue';
import MyPlugin from './myPlugin.js';
import App from './App.vue';

const app = createApp(App);

// 使用插件
app.use(MyPlugin);

app.mount('#app');
```

通过`install`函数，我们可以将插件的功能集中封装，并且可以轻松地在应用中安装和使用插件。



## 3.图片懒加载优化操作

![image-20230704234459091](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230704234459091.png)



图片懒加载完毕后，useIntersectionObserver函数中的isIntersecting变量还是会持续监听元素是否在可是窗口，但懒加载的图片当第一次出现在可视窗口后，加载完毕后就不需要在监听了，需要关掉

![image-20230705000109977](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705000109977.png)



### 插件定义和执行

执行顺序：

​	main.js引入定义的插件，也就是我们自定义懒加载指令，左图采用分别暴露，默认暴露为（export defalut ）,当浏览器执行代码时，先执行main.js中的导入代码import，随后app.use（lazyPlugin）调用插件，一旦执行，则来到插件定义的文件中，自动执行install函数，并把全局app作为参数，完成自定义指令的代码操作

![image-20230705000655854](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705000655854.png)



# 17.HomeProduct渲染

```
同样利用请求的数据渲染三个模块的Product模块，它同样套用了HomePanel组件的整体架构，用于搭建👇图的模块架子，只不过只有一级title，没有sub-title了，图片依旧使用懒加载v-img-lazy
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705121956960.png" alt="image-20230705121956960" style="zoom:50%;" />

![image-20230705122322767](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705122322767.png)

![image-20230705122420387](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705122420387.png)



# 18封装重复代码至GoodsItem组件

根据👆图发现，goods-list内部的小图都是相同架构，不同的数据，因此可以封装为一个组件，相同部分提取至GoodsItem组件中，将不同部分通过传参形式，用defineProps传递数据goods，在通过各自的数据渲染各自的小模块

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705132342859.png" alt="image-20230705132342859" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705132619408.png" alt="image-20230705132619408" style="zoom:50%;" />





# 19.面包屑导航

![image-20230705142139980](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705142139980.png)

依旧是从接口获取数据，并渲染页面

**[但不同的是]()**：页面部分跳转，所以用到了路由，发生改变的页面内容是Layout组件中li标签内的文本

获取接口的数据是对象类型，且页面是根据params参数改变进行路由切换的，所以我们用到了usrRoute获取当前页面的params.id参数，并通过params.id的改变切换路由，黑马提供的接口需要传递当前页面的params.id以此来返回对应的响应数据，比如1005000时居家的页面params.id，当点击居家时，需要携带该id调用接口发送请求，对应的居家组件的数据才会响应，并渲染页面



接口：																						页面组件：

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705142607331.png" alt="image-20230705142607331" style="zoom:55%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705143124726.png" alt="image-20230705143124726" style="zoom:55%;" />

导航栏页面组件：

![image-20230705142312964](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705142312964.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705143403849.png" alt="image-20230705143403849" style="zoom:50%;" /> 

## useRoute有什么用❓

```
在React Navigation中，`useRoute()`是一个自定义Hook，用于获取当前屏幕的路由信息。它返回一个包含当前路由参数和其他相关信息的对象。

使用`useRoute()`可以在组件中访问当前屏幕的路由参数，例如路由名称、参数等。这在需要根据不同的路由参数来进行条件渲染或执行不同的操作时非常有用。

以下是`useRoute()`的一些常见用途：

1. 获取当前屏幕的路由名称：`route.name`
2. 获取当前屏幕的路由参数：`route.params`
3. 根据当前路由参数进行条件渲染：例如根据不同的参数显示不同的内容
4. 在屏幕组件中使用导航方法：例如`route.navigate()`用于导航到其他屏幕

总之，`useRoute()`提供了一种方便的方式来获取和操作当前屏幕的路由信息，使得在React Navigation中处理导航和路由相关的逻辑变得更加简单和灵活。
```



# 20.二级分类复用轮播图

点击导航栏后，跳转的二级页面复用一级首页的轮播图

**[区别]()** 在于首页轮播图发送请求参数是1，二级分类页轮播图发送请求参数是2，这就需要修改接口请求的api，添加参数，默认首页是1，当调用二级分类路由api时（也就是点击导航栏）传递参数值为2

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705150710832.png" alt="image-20230705150710832" style="zoom:67%;" />![image-20230705150731532](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705150731532.png)



![image-20230705150126163](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705150126163.png)

![image-20230705150505992](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705150505992.png)

# 21.导航激活设置分类列表渲染

## 1. 导航激活状态设置

```vue
<RouterLink active-class="active" :to="`/category/${item.id}`">{{ item.name }}</RouterLink>
```

## 2. 分类数据模版

**[渲染导航栏点击后跳转的页面（二级页面）中的商品信息]()**

```html
<div class="sub-list">
  <h3>全部分类</h3>
  <ul>
    <li v-for="i in categoryData.children" :key="i.id">
      <RouterLink to="/">
        <img :src="i.picture" />
        <p>{{ i.name }}</p>
      </RouterLink>
    </li>
  </ul>
</div>
<div class="ref-goods" v-for="item in categoryData.children" :key="item.id">
  <div class="head">
    <h3>- {{ item.name }}-</h3>
  </div>
  <div class="body">
    <GoodsItem v-for="good in item.goods" :goods="good" :key="good.id" />
  </div>
</div>
```

# 22.响应路由参数变化

**[当链接地址的pramas参数发生变化时，相同的组件实例被复用，导致无法使用钩子，进而无法渲染导航栏们对应的商品信息]()**

### 路由缓存问题解决

> 缓存问题：当路由path一样，参数不同的时候会选择直接复用路由对应的组件
> 解决方案：
>
> 1. 给 routerv-view 添加key属性，破坏缓存
> 2. 使用 onBeforeRouteUpdate钩子函数，做精确更新

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705190510199.png" alt="image-20230705190510199" style="zoom:67%;" />



## 方法一：

**[在RouterView中添加key，强制让它不走缓存，不复用相同的组件实例]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705190607038.png" alt="image-20230705190607038" style="zoom: 67%;" />



## 方法二：

**[路由发生变化时（这里指params.id发生变化）调用onBeforeRouteUpdate（）这个钩子]()**

![image-20230705191043949](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705191043949.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705190828389.png" alt="image-20230705190828389" style="zoom:67%;" />

```
	onBeforeRouteUpdate（）钩子，监视所在路由，当路由发生变化时调用，这里我们点击导航栏，导致对应页面的params.id发生变化从而页面跳转
	于是我们利用params.id变化特点使用这个钩子，这个钩子有两个参数，其中一个时to，记录着目标路由对象信息，其中to.params.id即可取到目标路由参数，于是将此作为参数传递给getCategory函数，让它带着跳转的新的路由id发送请求，实现页面跳转。
	其中route.params.id是旧路由的id，我们用它来做默认值，以至于页面初始化时不会因为没有id而导致页面为空的情况
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705195927935.png" alt="image-20230705195927935" style="zoom:70%;" />

## 总结：

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705195802554.png" alt="image-20230705195802554" style="zoom:50%;" />



# 23.使用逻辑函数拆分业务

```
🔴组合式api：将原本一个组件中负责多个不同区域的业务逻辑函数，按照功能的不同拆分在composables文件下的子文件中（负责轮播图的代码放在useBanner.js中，负责分类逻辑的放在useCategory.js中），便于后期维护，最后拆分出去的api又通过导入的方式组合在原来的组件中使用，拆分出去再组合回来
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705203456568.png" alt="image-20230705203456568" style="zoom:50%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705205942648.png" alt="image-20230705205942648" style="zoom: 67%;" />

```
🔴原组件定义了两个功能的逻辑函数，一个负责轮播图逻辑，一个负责各个导航切换路由逻辑，将其拆分开来放在composables文件下分开管理，useBanner.js和useCategory.js，再将其各自逻辑代码放在对应的js文件中，曝光出去，最后再组合回最开始的组件中使用
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705210417041.png" alt="image-20230705210417041" style="zoom:70%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705210430887.png" alt="image-20230705210430887" style="zoom:67%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705210446643.png" alt="image-20230705210446643" style="zoom:70%;" />





# 24.二级分类面包屑导航

通过API发送请求得到数据实现路由跳转，此次跳转属于二级分类，地址上面与一级导航栏不同，是sub/10232323类型，后面的数字需要通过请求得到

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706001110858.png" alt="image-20230706001110858" style="zoom:67%;" />


**[接口函数													路由组件配置信息]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706000703639.png" alt="image-20230706000703639" style="zoom:60%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706001235444.png" alt="image-20230706001235444" style="zoom:70%;" />



**[二级分类组件]()**

![image-20230706001454809](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706001454809.png)



# 25.二级分类筛选页面渲染

**[获取商品信息业务逻辑代码]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706001526039.png" alt="image-20230706001526039" style="zoom:67%;" />



[**渲染工作**]()

![image-20230706001542269](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706001542269.png)



[**接口数据**]()

![image-20230705234909561](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230705234909561.png)







# 26.tab筛选栏实时监控

​	当点击不同得筛选条件时，能保证筛选字段sortField随之变化，我们利用elementUI组件提供的组件el-tabs和el-tab-pane配合使用，当某一个el-tab-pane被激活（点击）时，那个el-tab-pane的name值就会自动传递给el-tab中的v-model，成为v-model的值。（💡所以el-tab-pane中name值不能瞎写，一定要根据筛选字段规定的那几个筛选条件写）

​		此时el-tab可通过v-model绑定getSubCategoryAPI参数中的reqData.sortField属性（筛选字段/条件），从而实时监控和修改API的参数中的sortField值，让其带着全新的参数去发送请求，达到筛选栏实时监控筛选条件的目的

​		同时el-tabs支持绑定事件，这里使用@tab-change事件（当activeName被修改时触发，这里也就是v-model后面的reqData.sortField被修改时触发），绑定回调函数，当点击筛选栏筛选商品时，根据筛选条件修改reqData.sortField，从而触发回调tabChange，在回调中定义我们的逻辑

```
以下是接口api中参数的筛选字段，分别是按最新商品、最高人气、最高评价排序
sortField: 'publishTime' | 'orderNum' | 'evaluateNum'
```

**[elementUI]()**组件

![image-20230706135605718](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706135605718.png)

**[回调函数]()**

![image-20230706135546146](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706135546146.png)



# 27.商品列表无限加载

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706135806415.png" alt="image-20230706135806415" style="zoom:50%;" />



```
	v-infinite-scroll指令：当绑定指令的html元素(这里绑定了展示商品信息的模块class="body"这个div元素)，会一直监听用户滚动情况，只要滚到到元素底部，就会触发指定所绑定的回调
	当滚动加载到数据为空时（items已经为空了），停止v-infinite-scroll对元素的监听
```

![image-20230706143250089](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706143250089.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706142132647.png" alt="image-20230706142132647" style="zoom:67%;" />



```
🔴🔴🔴通过修改resDate.value.page值，达到修改getSubCategoryAPI的参数，并让API带着新参数不断发送新的请求，从服务器请求更多的新商品数据渲染页面
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706143458472.png" alt="image-20230706143458472" style="zoom:67%;" />



# 28.路由滚动条行为**[问题展示：]()**

[二级分类界面滚到中部位置											点击一级分类滚动条任在中部，滚动条应该恢复顶部]()

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706144030155.png" alt="image-20230706144030155" style="zoom:45%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706144045079.png" alt="image-20230706144045079" style="zoom:50%;" />

### 解决方法：

```
路由滚动行为定制(让该分类页面的滚动记录不会影响其他级别的分类级别滚动记录)

 比如二级分类中滚动条滑动到了页面中部，切换到一级分类时就可以让滚动条回到顶部
```

![image-20230706144200258](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706144200258.png)

# 

# 

# ================

# 详情（Detail）页设计



# 1.配置路由信息

**[1.创建文件 														2.搭建静态页面]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706154523513.png" alt="image-20230706154523513" style="zoom:67%;" />

**[3.配置路由信息														4.实现跳转（商品是在新鲜好物的路由组件HomeNew中）]()**

![image-20230706154649930](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706154649930.png)				<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706154813156.png" alt="image-20230706154813156" style="zoom:67%;" />





# 2.详情页基础数据渲染

获取对应商品信息的params.id，拿到对应数据实现渲染





## 1.详情页面包屑导航

**[展示：																			请求数据				]()**

![image-20230706163756496](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706163756496.png)	<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706164234483.png" alt="image-20230706164234483" style="zoom:67%;" />

**[组件内请求数据代码：]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706163835874.png" alt="image-20230706163835874" style="zoom:50%;" />



**[渲染页面代码：]()**

```
	💡根据请求得到的数据渲染面包屑导航内容，<el-breadcrumb-item>是elementUI组件库的面包屑导航，它是一种常见的页面导航方式，它以层级结构的方式展示当前页面所在的位置。每个面包屑项都是一个链接，点击可以返回到对应的页面。
		<el-breadcrumb-item> 组件底层确实使用了路由技术。当你给 <el-breadcrumb-item> 的 to 属性指定了一个路由地址时，点击该面包屑项会触发路由切换，跳转到对应的页面。
```

![image-20230706163710975](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706163710975.png)



### 🔴注🔴意🔴点：

```
👆图绿字解释
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706164751229.png" alt="image-20230706164751229" style="zoom:50%;" />





## 2.渲染页面信息

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706164234483.png" alt="image-20230706164234483" style="zoom:67%;" />





# 3.详情页热榜区域

![image-20230706203206473](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706203206473.png)



## 1.详情Detail页 组件文件创建及静态页面搭建

```
💡详情页需要展示的是24h热榜和周热榜，所以在详情页这个大组件index.vue中需要导入两个DetailHot.vue组件，因为它们两个榜的整体架构一样，只是数据不同
```

![image-20230706211206392](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706211206392.png)<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706211735795.png" alt="image-20230706211735795" style="zoom:90%;" />



## 2.API导入

```
💡这API有三个参数
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706211245883.png" alt="image-20230706211245883" style="zoom:67%;" />



## 3.获取热榜数据,渲染至页面

```
提供API需要的参数，用对象形式做参数
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706211343589.png" alt="image-20230706211343589" style="zoom:55%;" />





# 4.两个热榜信息详细设计

```
💡当你在子组件的 Props 中定义了一个名为hotType的属性时，子组件可以接收来自父组件的名为hot-type的数据。

​  这是因为在 HTML 中，属性名称是不区分大小写的，所以 hot-type 和 hotType 在 HTML 中是等价的。
```

详情页通过defineProps传递hotType数据，来决定title信息和获取的数据 



## 1.父组件传递Number类型的数据

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706223715384.png" alt="image-20230706223715384" style="zoom:60%;" />



## 2.子组件接收

DetailHot.vue用来接收外部index.js传递进来的hotType数值，来决定是获取24h热榜信息（hotType=1），还是周热榜信息（hotType=2）

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706223744445.png" alt="image-20230706223744445" style="zoom:67%;" />



## 3.决定两个热榜title标题

```
//适配两个热榜模块的title，hotType=1时，title="24小时热榜"；hotType=2时，title="周热榜单"
const TYPEMAP = {
    1: '24小时热榜',
    2: '周热榜单'
}
const title = TYPEMAP[props.hotType]
```

然后渲染到页面上



## 4.获取24h热榜/周热榜信息

**[依旧通过hotType值来确定]()**

```
💡🔴注意，props传递进来的数据，在内部使用要props.hotType，这和ref定义响应式数据一样在内部使用要加.value
```

```
 //通过API参数中type值，来分别获取24h热榜信息和周热榜信息，1是24h，2是周榜

  //所以对API参数中的type直接去修改，以拿到对应数据

​    type: props.hotType,//type参数决定了此次请求的信息是24h热榜还是周热榜（1是24h热榜信息）
```





# 5.图片预览组件

## 1.通过小图切换大图

![image-20230706224355418](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706224355418.png)

#### 步骤：

```
	通过mouseenter事件，实时获取鼠标所处小图的下标（次序号），从而通过这个次序号修改展示的大图
	而小图模块渲染是通过v-for遍历出来的，以此每个小图都有自己专属的i值，这也就是我们想要的小图次序号index，将i传入mouseenter的回调函数enterHandler中，以此来实时拿到鼠标经过的小图的下标
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706232723656.png" alt="image-20230706232723656" style="zoom:80%;" />

```
定义响应式数据activeIndex，实时拿到和修改鼠标移入的小图的小标
```

![image-20230706232809188](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706232809188.png)

```
最后通过数组方式渲染大图
```

![image-20230706233025078](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706233025078.png)

```
🔴💡大图列表
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230706233035047.png" alt="image-20230706233035047" style="zoom:50%;" />



### 小图动态类名绑定

鼠标最后一次经过的小图要加上active样式显示绿框框



## 2.图片放大镜效果  

```
获取鼠标相对于大图内的定位（vueuse中的useMouseInElement）
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707133738257.png" alt="image-20230707133738257" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707132718949.png" alt="image-20230707132718949" style="zoom:50%;" />

```
🔴中图：
    根据鼠标在中图中的坐标elementX和elementY，来定义中图内灰色蒙版区域的坐标，控制它的移动（也就是css样式中的left和top值）
    中图：400px*400px 
    灰色蒙版100px*100px
    通过watch不断监视鼠标的移动坐标信息，来实时改变蒙版的坐标信息left和top
    由于灰色蒙版有移动区域，在100<elementX<300,100<elementY<300,在中图中间正方形区域灰色蒙版才会移动，所以需要限定返回，超出范围灰色蒙版都在固定区域

🔴大图：
	放大镜大图的移动，和鼠标在中图内移动的方向相反，且距离是2倍关系
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707143153551.png" alt="image-20230707143153551" style="zoom:67%;" />



### 放大镜大图的显示和隐藏

依旧可以用到vueuse中的useMouseInElement函数，它提供数值isOutside判断鼠标是否在目标元素内

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707143325847.png" alt="image-20230707143325847" style="zoom:70%;" />



### 优化

由于watch会不断监视elementY和elementX，即使在中图外移动elementX也会不断监视并执行watch中的所有代码，而我们只想让：当鼠标在 中图内移动时的代码执行，至于鼠标在中图外移动的坐标我们不需要管，于是在watch中加上判断

```
    if (isOutside.value) return //如果鼠标不在中图中，就不需要执行下面的代码了
```



# 6.SKU组件

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707150918940.png" alt="image-20230707150918940" style="zoom:50%;" />

XtxSku组件文件夹

![image-20230707153430602](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707153430602.png)



在详情页创建实例并传递数据

![image-20230707153509290](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707153509290.png)



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707153520863.png" alt="image-20230707153520863" style="zoom:70%;" />



Sku组件内传递的props数据和emits事件

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707153611612.png" alt="image-20230707153611612" style="zoom:70%;" />





# 7.注册全局组件

```
components：目录下放置全局通用的组件，实现多个业务模块中共享
1.将components文件中的组件进行定义注册
2.到mian.js中注册这些全局组件，供整个项目随意使用
```

```
下👉图中，这段代码定义了两个全局通用组件：ImageView和XtxSku。然后通过Vue的install方法，在main.js中注册这两个组件。这样，在整个项目中就可以直接使用这两个组件了。
	install方法通过app.component方法注册了两个全局组件，即XtxImageView和XtxSku。这样，在main.js中调用Vue.use(componentPlugin)时，这两个组件就会被注册到Vue实例中，从而在整个项目中都可以使用它们。
```

![image-20230707155857152](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707155857152.png)<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707155928008.png" alt="image-20230707155928008" style="zoom:67%;" />

**[注册全局组件后，在任何地方使用时无需导入，直接使用实例即可]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707160233444.png" alt="image-20230707160233444" style="zoom:70%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707160312109.png" alt="image-20230707160312109" style="zoom:70%;" />





# 

# ================

# 登录页面Login

# 1.页面搭建

![image-20230707163344089](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707163344089.png)

# 2.路由跳转

**[首页 => 登录]()** 

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707163212616.png" alt="image-20230707163212616" style="zoom:75%;" />

**[登录 => 首页]()**

![image-20230707163253370](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707163253370.png)





# 3.表单校验

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707163647943.png" alt="image-20230707163647943" style="zoom:50%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707163720322.png" alt="image-20230707163720322" style="zoom:67%;" />

  

```
🔴🔴🔴🔴🔴🔴🔴使用演示：
```

![image-20230707164316529](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707164316529.png)



**[使用步骤：]()**

```
🔴1.准备表单对象的信息：用户名和密码
```

```
const form = ref({
    account: '',
    password: ''
})
```

```vue
🔴2.准备规则对象rules，为每个表单对象form中的信息进行规则制定
```

```javascript
const rules = {
    account: [
        //required: true设置该内容必须填写（也就是用户名密码表单必须添加）
        { required: true, message: '用户名不能为空', trigger: 'blur' }//blur失去焦点时触发
    ],
    password: [
        { required: true, message: '密码不能为空', trigger: 'blur' },
        { min: 6, max: 14, message: '密码长度为6-14个字符', trigger: 'blur' }
    ],

}
```

```
🔴3.到elementsUI组件实例中去绑定准备的信息
```

```vue
 <!-- 根据elementUI组件库中el-form组件要求，在最外层加上最关键的:model="form" -->
	<el-form :model="form" :rules="rules" label-position="right" label-width="60px" status-icon>
        ==========================================用户名框
        <!-- prop="account"指定表单校验字段名-->
        <el-form-item prop="account" label="账户">
            <!-- 双向绑定表单对象 -->
            <el-input v-model="form.account" />
        </el-form-item>
    	==========================================密码框
        <el-form-item prop="password" label="密码">
            <el-input v-model="form.password" />
        </el-form-item>
```



# 4.自定义校验规则

![image-20230707225000247](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707225000247.png)



```
	自定义校验规则在规则rules中的定义会不一样，使用了叫做验证器validator的函数，有三个参数，这里时遇到了value和callback参数，用来获取用户协议checkbox框的值为true/false，
	true同意则调用callback函数，
	否则调用参数错Error的callback函数（💡这里注意不管是否同意都需要执行callback函数），这样不勾选用户协议框就会执行else callback(new Error('请勾选用户协议'))，报错提醒用户勾选用户协议
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707230658954.png" alt="image-20230707230658954" style="zoom:67%;" />



```
在elementUI组件中，用户名和密码组件使用规则相同
🔴最内层（直接获取到数据的那层）双向绑定表单对象v-model="form.agree"实时获取到勾选框的状态，外层指定指定agree规则prop="agree"
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707231108822.png" alt="image-20230707231108822" style="zoom: 67%;" />



# 5.表单统一全部校验

```
	当用户一上来就点击登录时，不会执行上上图中的逻辑
	这里通过ref绑定一个组件实例（也就是整个el-form表单实例），通过这个form实例的方法validate函数（🔴参数时valid），他会对ref绑定表单内所有表单进行校验，只有所有表单都校验通过vaild才会显示true
```

**[表单部分]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707232505678.png" alt="image-20230707232450037" style="zoom:67%;" />



**[逻辑代码部分]()**

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707232450037.png" alt="image-20230707232450037" style="zoom:67%;" />



# 6.实现登录功能

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707232830902.png" alt="image-20230707232830902" style="zoom:80%;" />



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708001213679.png" alt="image-20230708001213679" style="zoom:80%;" />



## 登录校验API

```
点击登录后，需要调用loginAPI接口，对用户名和密码进行后台校验，这个loginAPI接口需要提供用户名和密码两个参数，以此来验证用户名是否存在
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708001438593.png" alt="image-20230708001438593" style="zoom:60%;" />

```
💡通过和未通过时的响应
```

![image-20230708001652229](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708001652229.png)

![image-20230708001730621](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708001730621.png)

## 若登录成功

### 1.提示用户

```
若通过验证，则返回，则执行两个步骤：
 		 1.提示用户(这里使用饿了么组件库中的ElMessage组件，实现弹窗提示)
            ElMessage({ type: 'success', message: '登录成功' })
```

```
💡需要导入方法和样式文件才行
import { ElMessage } from 'element-plus'
import 'element-plus/theme-chalk/el-message.css'
```

![image-20230707235414571](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230707235414571.png)



### 2.实现路由跳转

```
	由于我们以前都是在template也就是html中用RouteLink进行路由跳转，所有在组合式script中，若想实现路由跳转至首页，需要用到useRouter函数，通过它返回对象身上的replace方法实现页面跳转
💡注意区分：
	// useRoute是获取参数（如params.id等等）
	// useRouter是调用方法，返回一个对象
	import { useRouter } from 'vue-router'
	
	const router = useRouter()
    router.replace({ path: '/' })
```



## 登录失败

```
若不通过，则响应失败，由于很多接口都会用到 校验用户登录这个请求，无需一个一个得提示用户用户名无效，所以直接在响应拦截器中对登录请求失败时处理
```

![image-20230708002020608](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708002020608.png)



### 





# 7.Pinia管理用户信息

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708133719944.png" alt="image-20230708133719944" style="zoom:67%;" />

![image-20230708133751749](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708133751749.png)

```
本节主要做用户信息通过pinia统一管理
	在组件中首先用户点击登录，触发pinia中的action函数，将用户名和密码作为参数传入函数中，再让action帮我们调用loginAPI接口验证用户信息的正确性
	在pinia中，我们要将用户信息存储在此处userInfo中，并在action中调用loginAPI，API调用后将用户提交的用户名和密码上传至服务器进行验证，返回成功的响应时，被pinia中的state的getUserInfo接收到并存取，至此，达成了用户信息统一保存管理的目的
```

![image-20230708134420601](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708134420601.png)





# 8.Pinia用户数据持久化

```
🔴🔴🔴🔴🔴🔴通过pinia组件将用户数据存在浏览器的本地存储中

🔴🔴🔴🔴🔴🔴这个插件会将本地存储的数据始终和pinia中的state（数据）（这个章节是使userInfo）保持同步
				
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708135213063.png" alt="image-20230708135213063" style="zoom:60%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708140737710.png" alt="image-20230708140737710" style="zoom:50%;" />

```
1.安装插件包
npm i pinia-plugin-persistedstate

2.引入pinia插件piniaPluginPersistedstate
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'

3.注册持久化插件，用于持久化保存用户登录信息（暂存在浏览器的本地存储中，一段时间内无需每次都重新登录）
const pinia = createPinia()
pinia.use(piniaPluginPersistedstate)

4.在统一存储用户数据store文件中配置，pinia用户信息持久化操作
    {
        persist: true,
    }
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708140855805.png" alt="image-20230708140855805" style="zoom:67%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708140633169.png" alt="image-20230708140633169" style="zoom:50%;" />





# 9.登录/非登录下页面显示

```
🔴根据条件，选择对应的模块进行展示
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708160516148.png" alt="image-20230708160516148" style="zoom:67%;" />

```
🔴判断用户有无登录,从而修改首页最上方的v-if数值,达到修改首页最上方用户登录的页面显示，我们只需要根据token决定用户是否登录成功,而我们将登录成功的响应保存在了pinia管理的store文件下的userInfo中,因此可以通过userInfo.token拿到它,因此v-if="userStore.user Info.token"即可控制用户登录和未登录的页面显示

💡通常情况下，成功的登录响应会包含一个用于身份验证和授权的访问令牌（token）。这个令牌可以被存储在客户端，然后在后续的请求中作为身份验证的凭证发送给服务器。服务器可以使用这个令牌来验证用户的身份，并对其进行授权访问受保护的资源。令牌可以存储在客户端的本地存储（如浏览器的localStorage或cookie），以便在会话期间持久保存，并在需要时发送给服务器。
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708160616703.png" alt="image-20230708160616703" style="zoom:60%;" />





# 10.请求拦截器携带token

```
token作为用户的唯一标识，很多接口都需要根据用户的token鉴权，来判断是否要对该用户的请求做出响应

这里我们选择在请求拦截器中，将用户登录后的唯一标识token一并上传至服务器（通常将token放在请求头中发送请求），这样就可以避免每次调用api时都要传递用户的token，通过请求拦截器中上传token直接一次性满足所有需要用户token的api
	💡config.headers.Authorization = `Bearer ${token}`
	🔴这句代码是根据后端的要求配置的，它们将用户token放在请求头中并上传至服务器
```

![image-20230708162124912](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708162124912.png)

![image-20230708163515980](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708163515980.png)



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708162908041.png" alt="image-20230708162908041" style="zoom:67%;" />





# 11.退出登录

![image-20230708163742190](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708163742190.png)



```
这里使用了组件库中的<el-popconfirm>，点击某个元素弹出一个简单的气泡确认框
可以绑定事件，分别是：1.定触发的confirm事件
				  2.点击取消的concel取消事件
```

```
//退出登录的业务逻辑
const confirm = () => {
    // console.log('退出登录');
    //1.清除用户信息,触发store中的action(clearUserInfo函数)
    userStore.clearUserInfo()
    //2.跳转至登录页面
    router.replace({ path: '/login' })
}
```

![image-20230708202420507](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708202420507.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708202043403.png" alt="image-20230708202043403" style="zoom:50%;" />



# 12.token失效401拦截

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708202625273.png" alt="image-20230708202625273" style="zoom:50%;" />



```
	🔴在登录状态下，在网页中很多操作都涉及到了token检查，当某次操作发送请求时携带的token失效了，那么会响应状态码401的错误状态，因此我们通过这个状态码做token失效的操作，由于很多请求都需要检查token，所有我们在响应拦截器中做token失效的统一操作

在商品详情页中打开本地存储删除用户几个的token值，再刷新就会触发token失效的操作
💡小兔鲜项目的后台应该只在商品详情页才检查了token
```

![image-20230708204412775](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708204412775.png)<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708204129507.png" alt="image-20230708204129507" style="zoom:80%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708204111833.png" alt="image-20230708204111833" style="zoom:67%;" />





# 

# 

# ================

# 购物车模块

![image-20230708204747209](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708204747209.png)

 

# 

# 🔴本地购物车（未登录）

# 1.本地购物车-加入购物车

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708221455435.png" alt="image-20230708221455435" style="zoom:67%;" />



```
v-model="count"将count变量与<el-input-number>组件的值进行了双向绑定。因此，当你修改输入框中的值时，count的值会自动更新；同时，当你修改count的值时，输入框中的值也会自动更新。
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708235259700.png" alt="image-20230708235259700" style="zoom:80%;" />![image-20230708235312238](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708235312238.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708224738719.png" alt="image-20230708224738719" style="zoom:70%;" />

```
💡skuId是每个商品的唯一标识，当用户既选择了商品规格，又选择商品数量后，才会生成一个完整的sku对象，否则都是空对象
所以我们可以根据sku.skuId判断商品款式是否选好了，是否可以加入cartList购物车列表中
```

```
	在详情页组件中，我们调用Store中cart.js文件中的useCartStore对象的addCart方法，主要用于传递数据添加至购物车列表中，首先是获取商品数量count值，其次我们通过sku.skuId判断用户是否将商品数量、款式、尺码等商品规格都选好了
	若都选好了，将每个商品的各个信息作为参数传递给addCart函数中，调用cart.js中的action（addCart函数）完成添加商品至购物车的操作
	若没选好，跳出警告弹窗
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708235340468.png" alt="image-20230708235340468" style="zoom:67%;" />

```
由于购物车信息在多个模块中都需要，所以要在pinia中统一管理购物车数据cartList
在购物车Store中，state是cartList，action是addCart
	在函数addCart中，主要实现添加商品信息至购物车列表中cartList，此函数接收商品信息goods对象作为参数，首先需要对比cartList中所有商品的skuId 是否和 添加至购物车的商品skuId有相同的
	若有相同的商品添加至购物车，只需要对购物车列表中那个相同商品的数量 加上添加商品的数量即可
	如果没有相同的，直接将完整商品信息goods添加至购物车列表中
最后对购物车列表数据做持久化处理，使用pinia插件
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230708233929525.png" alt="image-20230708233929525" style="zoom:60%;" />



# 2.购物车渲染和删除

```
渲染：购物车数据都存在cartList中，只需要根据此数组，配合v-for渲染购物车模块
删除：删除购物车只需要传递该件商品的skuId，随后在Store统一管理购物车数据的cart.js文件中调用delCart函数		即可在cartList中删除与skuId相匹配的商品信息
```

```
渲染
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709142300394.png" alt="image-20230709142300394" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709142322085.png" alt="image-20230709142322085" style="zoom:67%;" />

```
删除：这里使用了两个方法，都可以实现删除对应商品
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709142515181.png" alt="image-20230709142515181" style="zoom:67%;" />





# 3.购物车数量和价格统计

```
计算总的商品数量和总的商品价格，需要在统一管理数据的Store文件中调用计算属性方法，根据购物车列表进行计算
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709142816014.png" alt="image-20230709142816014" style="zoom:67%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709141938003.png" alt="image-20230709141938003" style="zoom:50%;" />



# 4.购物车界面跳转和渲染

## 1.路由跳转

```
配置路由参数，点击实现跳转
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709150548327.png" alt="image-20230709150548327" style="zoom: 67%;" />



![image-20230709150635805](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709150635805.png)



## 2.页面渲染

```
配置购物车页面专属文件，购物车信息引入，v-for渲染
```

![image-20230709150717375](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709150717375.png)<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709150756815.png" alt="image-20230709150756815" style="zoom:60%;" />



# 5.购物车单选功能

![image-20230709150439456](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709150439456.png)

```
通过拆解v-model，让他变为原始状态，拆分成:model-value和change事件
	使用:model-value="i.selected",使得单选框的状态和商品的selected属性保持同步，该件商品信息中的selected:'true'时，:model-value控制单选框保持勾选状态
	使用change事件，当点击单选框后，即修改了对应商品的selected值，selected值一修改，单选框的勾选状态也跟着修改，于是change事件做的事情就是将该件商品的selected做修改
	这样就达到了单选框的勾选状态和该商品的selected值保持同步关系
```

```
Store文件中action
```

![image-20230709195008551](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709195008551.png)

```
物车结算界面组件CartList组件内script
```

![image-20230709194953152](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709194953152.png)

```
购物车结算界面组件CartList中template
```

![image-20230709194933259](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709194933259.png)





# 6.购物车全选功能

![image-20230709195312051](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709195312051.png)

## 1.单选决定全选

```
💡所有单选状态都选中时，修改全选的状态
```

```
购物车结算界面组件CartList中template
```

![image-20230709201014081](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201014081.png)

```
Store中的计算属性（相当于vuex中的getters）
```

![image-20230709201029351](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201029351.png)



## 2.全选决定单选

```
💡让所有单选的状态都根据全选框的状态决定
```

```
购物车结算界面组件CartList中template
```

![image-20230709201153280](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201153280.png)

```
购物车结算界面组件CartList中script ，点击全选框后触发的回调函数
```

![image-20230709201211320](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201211320.png)

```
Store中的action ------allCheck
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201256750.png" alt="image-20230709201256750" style="zoom:70%;" />





# 7.购物车统计数据

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709201639622.png" alt="image-20230709201639622" style="zoom:70%;" />

```
🔴通过每个商品的seleted选中状态来统计，先filter筛选seleted为真（该商品被选中）的商品作为新数组，再对新数组调用reduce做统计（数量统计和价格总计）
```

```
Store中的计算属性，这两个数据做pinia统一管理
```

![image-20230709203156724](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709203156724.png)

```
购物车结算界面组件CartList中template
```

![image-20230709203330140](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709203330140.png)







# 🔴接口购物车（已登录）

![image-20230709220622753](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709220622753.png)



# 1.加入购物车

![](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709224901087.png)

```
apis/cart.js
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709225526584.png" alt="image-20230709225526584" style="zoom: 53%;" />

```
Store/cart.js
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709225128895.png" alt="image-20230709225128895" style="zoom:60%;" />

```
🔴接口购物车和本地购物车最大的区别在于用户有无登录，而判断用户有无登录是跟据用户信息中的token决定的，因此先获取到用户信息中的token，对token进行判断再做接口/本地购物车的相关逻辑
🔴在登录状态下 进行添加商品至购物车操作时，发了两次请求，就走了接口购物车的逻辑
	一次是加入购物车insertCartAPI
	一次是获取最新的购物车列表findNewCartListAPI
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709224640794.png" alt="image-20230709224640794" style="zoom:67%;" />





# 2.删除购物车

![image-20230709225257719](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709225257719.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709225635643.png" alt="image-20230709225635643" style="zoom:60%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709230510405.png" alt="image-20230709230510405" style="zoom:60%;" />



```
🔴登录状态下：点击购物车列表中删除操作，调用删除功能的API，下面两个请求第一个时调用删除接口时的请求，第二个是将删除后的新购物车列表信息覆盖旧的购物车列表信息
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709230318343.png" alt="image-20230709230318343" style="zoom:50%;" />



# 

# 退出登录清除本地存储购物车信息



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709232757581.png" alt="image-20230709232757581" style="zoom:50%;" />

```
在store下user.js文件中找到退出登录的逻辑，在这里调用购物车cart.js中的清空购物车函数
```

![image-20230709234226657](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709234226657.png)



![image-20230709234348016](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230709234348016.png)





# 合并购物车列表

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710095230602.png" alt="image-20230710095230602" style="zoom:50%;" />

```
1.在点击登录后，执行登录逻辑时，执行合并购物车操作.
通过map方法，将所需要的数据作为对象数组组合起来，作为合并购物车API的参数
该API将非登录状态下购物车信息保存起来，登录后，将保存的信息合并到登录状态下的购物车内，形成一个新cartList，并调用updateNewList这个action实现新数据castList覆盖旧castList
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710110019632.png" alt="image-20230710110019632" style="zoom:67%;" />

```
Store中cart.js下action
```

![image-20230710110150186](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710110150186.png)

```
合并购物车mergeCartAPI
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710110313969.png" alt="image-20230710110313969" style="zoom:80%;" />







# 

# 

# ================

# 订单结算单页面

# 1.页面渲染

```
从购物车界面 跳转到 下单界面，路由跳转，并实现基础数据渲染
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710130948525.png" alt="image-20230710130948525" style="zoom:50%;" />

 

```
1.静态页面搭建 			   views/Checkout/index.vue
2.路由跳转				 	path:/checkout
3.封装获取结算界面信息api  	getCheckoutInfoAPI()
4.获取相关数据进行页面渲染（通过api获取结算界面数据checkInfo和默认地址curAddress）
默认地址是根据checkInfo.userAddresses数组中获取isDefault=0的那个元素（也就是默认地址的信息）
	👇图
```

![image-20230710135232755](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710135232755.png)



![image-20230710135548284](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710135548284.png)





# 2.切换地址

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710135848779.png" alt="image-20230710135848779" style="zoom:60%;" />

## 1.点击按钮打开弹窗

```
	弹窗选择了饿了么组件<el-dialog>,可以通过v-model控制是否打开弹窗，默认是false
	const showDialog=ref（false）（默认false），通过showDialog控制弹窗开启，true为打开
	切换地址按钮绑定toggleFlag事件，用来修改showDialog的值为true，再配合v-model=“showDialog”达到打开弹窗的目的，当点击组件<el-dialog>中的X号时，会关闭弹窗，而此时的v-model绑定的showDialog自动变为false
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710142445244.png" alt="image-20230710142445244" style="zoom:60%;" />





## 2.修改地址

```
	通过item可以再配合@click事件chengeAddress(item)，可以实现拿到点击的那项地址数据，将他保存到activeAddress变量中，这样可以通过点击随时拿到对应的地址信息（💡点击哪条地址就为他添加样式active）
	点击确定，正式进行原地址信息curAddress覆盖，然后数据修改页面重新渲染，最后关闭弹窗
```

![image-20230710150907268](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710150907268.png)



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710151014938.png" alt="image-20230710151014938" style="zoom:80%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710151329915.png" alt="image-20230710151329915" style="zoom:67%;" />



# 3.生成订单

![image-20230710152330022](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710152330022.png)



```
1.支付组件Pay静态页面搭建
2.调用生成顶单接口createOrderAPI，此接口会返回订单号，该订单号需要在点击提交订单按钮，路由跳转到Pay组件   时作为query参数发送
3.生成订单后，购物车数据cartList直接清空，调用Stores下cart.js下的action
```

```
D:\vs code学习文件\vue3小兔鲜项目\src\apis\checkout.js
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710202412184.png" alt="image-20230710202412184" style="zoom:67%;" />

```
生成订单代码实现
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710201956656.png" alt="image-20230710201956656" style="zoom:70%;" />

# 

# 

# ==============

# 支付页



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710203504017.png" alt="image-20230710203504017" style="zoom:50%;" />

# 1.获取订单页所需数据

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710212728266.png" alt="image-20230710212728266" style="zoom:67%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710212807180.png" alt="image-20230710212807180" style="zoom:67%;" />

```
countdown表示当前支付时间超时
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710212414915.png" alt="image-20230710212414915" style="zoom:67%;" />







# 2.实现支付功能

```
前端只需要负责虚线框中的内容
```

![](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710212947787.png)



```
🔴实现点击跳转至支付界面
```

![image-20230710214226814](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710214226814.png)

![image-20230710214252609](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710214252609.png)

# 3.支付结果展示

![image-20230710214408029](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710214408029.png)

```
支付结果链接，其中payResult表示支付结果，我们用它的值来判断是否支付成功，💡payResult的值是字符串类型
http://127.0.0.1:5173/paycallback?payResult=true&orderId=1678393474077954049❌
http://localhost:5173/paycallback?payResult=true&orderId=1678393474077954049
```

```
1.路由
```

![image-20230710223637957](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710223637957.png)

```
2.其中的支付成功/失败的图标和字体通过链接中的query参数获取，$route.query.payResult判断支付结果，配合	v-if和v-else渲染支付成功/失败的图标，文字也一并渲染

💡payInfo.payMoney?.toFixed(2)，这里用到了可选链操作符，它允许您在访问对象属性或调用方法时，安全地处理可能为null或undefined的中间值（由于payInfo这个数据是调用API获取的，所以如果没来的及获取到数据时,toFixed操作会报错）。在使用?.操作符时，如果中间值为null或undefined，表达式的结果将为undefined，而不会导致错误。
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710223932202.png" alt="image-20230710223932202" style="zoom:67%;" />

```
3.渲染支付结果页面订单金额
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710223852678.png" alt="image-20230710223852678" style="zoom:67%;" />



# 4.封装倒计时函数

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710224436858.png" alt="image-20230710224436858" style="zoom:50%;" />

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230710224556019.png" alt="image-20230710224556019" style="zoom:50%;" />



```
💡第三方格式化插件dayjs，用于将秒数，指定成格式化的样子：dayjs.unix(time.value).format('mm分ss秒')
npm i dayjs
```

```
	要实现支付页Pay/index.vue下的定时器操作，我们选择将倒计时函数写在composables文件下【用于存放通用逻辑函数(💡倒计时操作)，可复用的逻辑代码片段】，叫countDown.js
	函数名为useCountDown，无参数，返回值为对象return {formatTime,start}
	start函数是做倒计时操作，传入一个参数（总秒数），并不断修改响应式数据time
	time.value修改，配合了计算属性computed，当time一修改就调用，此计算属性主要做时间格式化操作（格式化为'mm分ss秒'的形式），最后将格式化结果给formatTime,此时formatTime就是一个不断变化的倒计时
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711000348712.png" alt="image-20230711000348712" style="zoom: 60%;" />

```
	在使用该函数useCountDown时，我们使用解构赋值，将商品信息中的倒计时秒数payInfo.value.countdown取出，放在start函数中做参数，形成倒计时操作
	经过start函数的执行，修改了time，同时也间接修改了formatTime，将formatTime放置页面中即可形成倒计时操作
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711000025437.png" alt="image-20230711000025437" style="zoom:67%;" />

# 5.倒计时内存溢出解决

```
👆图倒计时优化操作：
 	onUnmounted(() => {
        if (timer) clearInterval(timer)//如果定时器存在，则关闭定时器
    })
```





# 

# 

# ==============

# 会员中心

![image-20230711131629172](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711131629172.png)

# 1.页面搭建和路由配置

```
🔴静态页面搭建，路由配置，个人中心和用户订单 属于 会员中心页 的 子路由，属于三级路由
```

![image-20230711133026126](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711133026126.png)<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711133131719.png" alt="image-20230711133131719" style="zoom:70%;" />



# 2.订单页和用户页渲染

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711133001272.png" alt="image-20230711133001272" style="zoom:50%;" />



```
🔴会员中心页下，两个三级路由的渲染：个人中心和我的订单
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711142114999.png" alt="image-20230711142114999" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711142134166.png" alt="image-20230711142134166" style="zoom:50%;" />



# 3.我的订单--tab切换

```
🔴我的订单中页面数据是通过getUserOrder接口获取的，其中有一个参数orderState，修改它来获取到不同状态栏所需要的数据
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711142526509.png" alt="image-20230711142526509" style="zoom:50%;" />

 

```
🔴🔴🔴el-tab-pane被切换时，el-tabs组件会触发tab-change事件，
       并且该事件的回调函数会有一个默认参数type,即被切换的那个tab栏的索引值
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711145242135.png" alt="image-20230711145242135" style="zoom:55%;" />





# 4.我的订单-分页功能

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711161236142.png" alt="image-20230711161236142" style="zoom:50%;" />



## 1.el-pagination组件

```
💡el-pagination组件
```

![image-20230711154559889](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711154559889.png)

![image-20230711154532984](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711154532984.png)



## 2.具体实现

```
	分页功能是依据el-pagination组件配合实现的，从getUserOrder获取的订单数据中，counts是该用户购买的商品总数，将他赋值给total，并放到el-pagination渲染
  💡总页数=总商品数/每页展示数
  💡每页展示数是由后台决定的，这里是每页2条数据
	接着绑定current-change事件，每当用户修改页码数时，el-pagination组件就会将修改后的页码 作为默认参数 传递给current-change事件的回调，进而修改getUserOrder所需的参数params中的page，并重新发送请求，获取对应页码的订单数数据，然后自动更新渲染新的页面
```

![image-20230711161329047](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711161329047.png)



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711162045807.png" alt="image-20230711162045807" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711161715506.png" alt="image-20230711161715506" style="zoom:55%;" />



# 5.优化

## 1.初始化三级路由

```
·初始化时就显示三级路由组件UserInfo（打开会员中心 就显示 三级路由我的订单）
·路由配置中path 置空操作
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711162530612.png" alt="image-20230711162530612" style="zoom:55%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711162509406.png" alt="image-20230711162509406" style="zoom:60%;" />



## 2.我的订单中订单状态

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711162810004.png" alt="image-20230711162810004" style="zoom:60%;" />

```
根据订单信息中的订单状态（一个数字），将他作为参数传递fomartPayState函数，返回文字，并渲染到页面
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711163736699.png" alt="image-20230711163736699" style="zoom:67%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711163808637.png" alt="image-20230711163808637" style="zoom:60%;" />



# 

# 

# ===============

# SKU组件（商品规格）

![image-20230711225234214](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711225234214.png)

# 1.基础页面渲染

```
调用接口获取数据，通过props传递数据goods进sku组件中
```

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711232409094.png" alt="image-20230711232409094" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711232430520.png" alt="image-20230711232430520" style="zoom:50%;" />



<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711232358350.png" alt="image-20230711232358350" style="zoom:80%;" />



# 2.点击规格更新选中状态

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711232246480.png" alt="image-20230711232246480" style="zoom:50%;" />





# 3.规格禁用实现

![image-20230711234251099](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711234251099.png)





![image-20230711235037743](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230711235037743.png)

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230712000410883.png" alt="image-20230712000410883" style="zoom:50%;" /><img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230712125115662.png" alt="image-20230712125115662" style="zoom:50%;" />



# 4.初始化规格禁用

![image-20230712125044812](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230712125044812.png)



# 5.点击规格更新禁用状态

<img src="C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230712130440128.png" alt="image-20230712130440128" style="zoom:67%;" />



# 6.产出SKU数据

![image-20230712135834685](C:\Users\11569\AppData\Roaming\Typora\typora-user-images\image-20230712135834685.png)
